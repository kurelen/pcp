#!/usr/bin/env node

const fs = require("fs");
const command_line_args = require("command-line-args");
const command_line_usage = require("command-line-usage");
const pcp = require("../src/pcp.js");

function iterate_search_space(options) {
    const {
        dominos,
        budget: { start, end, step },
        explore,
        verbose,
        reverse,
    } = options;
    const log = verbose ? console.log : noop;

    for (let budget = start; budget <= end; budget += step) {
        log("Search with budget " + budget);

        const solution = pcp.solve({ ...options, budget });
        if (solution === undefined) {
            return { type: "error" };
        }
        else if (solution.length !== 0) {
            return { type: "found", result: solution };
        }
    }
    return { type: "not_found" };
}

function noop() {
    return undefined;
}

function process_options(options) {
    const { dominos, explore, verbose } = options;
    const log = verbose ? console.log : noop;
    const dom_s = dominos
        .map((domino, index) => `${index + 1}:(${domino[0]},${domino[1]})`)
        .join(" ");

    log("Dominos  > " + dom_s);
    if (explore.length > 0) {
        log("Explore  > " + explore.map((i) => i + 1).join(","));
    }

    const solution = iterate_search_space(options);
    const { type, result } = solution;

    switch (type) {
        case "error":
            console.log("Invalid start configuration");
            log("Top      > " + explore.map((i) => dominos[i][0]).join(""));
            log("Bottom   > " + explore.map((i) => dominos[i][1]).join(""));
            return;
        case "not_found":
            console.log("No solution found");
            return;
        default:
            log("Found solution of length " + result.length);
            log("Solution > ")
            console.log(result.map((i) => i + 1).join(","));
            log("Top      > " + result.map((i) => dominos[i][0]).join(""));
            log("Bottom   > " + result.map((i) => dominos[i][1]).join(""));
    }
}

const options_definition = [
    {
        name: "dominos",
        alias: "d",
        type: String,
        multiple: true,
        description:
            'Dominos in format "top,bottom" seperated by spaces. Example: --dominos',
    },
    {
        name: "read",
        alias: "r",
        type: String,
        typeLabel: "{underline file}",
        description: "Read dominos from a file (whitespace separated)",
    },
    {
        name: "budget",
        alias: "b",
        type: String,
        typeLabel: "{underline range}",
        description:
            'Budget range. Examples: "200" for a single value, "200..210" for range with step 1, "200..200:2" for custom step',
    },
    {
        name: "explore",
        alias: "e",
        type: Number,
        multiple: true,
        typeLabel: "{underline indices...}",
        description:
            "Start with specific domino indices (1-based). Example: --explore 4 2",
    },
    {
        name: "limit",
        alias: "l",
        type: Number,
        typeLabel: "{underline amount}",
        description: "Limit the amount of operations available for each budget"
    },
    {
        name: "help",
        alias: "h",
        type: Boolean,
        description: "Display this usage guide",
    },
    {
        name: "reverse",
        alias: "x",
        type: Boolean,
        description: "Iterate over dominos in reverse order",
    },
    {
        name: "verbose",
        alias: "v",
        type: Boolean,
        description: "Verbose output",
    },
];

const range_regex = /^(\d+)(\.\.(\d+)(:(\d+))?)?$/;
const domino_regex = /^([^,\s]+),([^,\s]+)$/;
const whitespace_regex = /\s+/;

function read_dominos(filePath) {
    const content = fs.readFileSync(filePath, "utf-8");
    return content.split(whitespace_regex);
}

function validate_options(options) {
    const { budget, dominos, read, explore, limit, help, reverse, verbose } = options;
    const result = { help, limit, reverse, verbose };

    if (budget === undefined) {
        throw new Error("Missing budget (--budget)");
    }
    const match = budget.match(range_regex);
    if (!match) {
        throw new Error('Invalid budget range "' + budget + '"');
    }
    const start = parseInt(match[1], 10);
    const end = match[3] ? parseInt(match[3], 10) : start;
    const step = match[5] ? parseInt(match[5], 10) : 1;
    if (start > end) {
        throw new Error("Invalid range, " + start + " > " + end);
    }

    if (limit !== undefined && Number.isSafeInteger(limit) && limit <= 0) {
        throw new Error("Limit must be positive integer, supplied " + limit);
    }

    result.budget = { start, end, step };

    if (dominos !== undefined && read !== undefined) {
        throw new Error("Mutual exclusive arguments '--dominos' and '--read'");
    }
    const ds = (dominos ?? read_dominos(read ?? 0))
        .map((s) => s.trim())
        .filter((s) => s !== "");

    if (ds.length === 0) {
        throw new Error("Dominos must not be empty");
    }

    result.dominos = ds.map((domino) => {
        const domino_match = domino.match(domino_regex);
        if (
            domino_match === undefined ||
            domino_match[1] === undefined ||
            domino_match[2] === undefined
        ) {
            throw new Error('Invalid formatted domino "' + domino + '"');
        }
        return [domino_match[1], domino_match[2]];
    });

    const dominos_amount = result.dominos.length;

    result.explore = (explore ?? []).map((index) => {
        if (0 < index && index <= dominos_amount) {
            return index - 1;
        }
        throw new Error(
            'Explore value "' +
                index +
                '" out of bounds, only ' +
                dominos_amount +
                " dominos supplied"
        );
    });

    return result;
}

const usage_definition = [
    {
        header: "PCP Solver",
        content: "Solves Post Correspondence Problem instances",
    },
    {
        header: "Options",
        optionList: options_definition,
    },
    {
        header: "Examples",
        content: [
            {
                desc: "1. Using stdin",
                example: "$ node pcp.js --budget 200..210:2",
            },
            {
                desc: "2. Inline dominos",
                example:
                    "$ node pcp.js --dominos 11101,0110 110,1 1,1011 --budget 302",
            },
            {
                desc: "3. From file",
                example:
                    "$ node pcp.js --open dominos.txt --budget 200..210 --reverse",
            },
            {
                desc: "4. With explore",
                example:
                    "$ node pcp.js --dominos 000,0 0,111 11,0 10,100 --budget 202 --reverse --explore 4 2",
            },
        ],
    },
];

function main() {
    let options;
    try {
        options = validate_options(command_line_args(options_definition));
    } catch (err) {
        console.error(err.message);
        console.log(command_line_usage(usage_definition));
        process.exit(1);
    }

    if (options.help) {
        console.log(command_line_usage(usage_definition));
        process.exit(0);
    }

    process_options(options);
}

main();
